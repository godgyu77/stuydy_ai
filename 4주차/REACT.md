# 📘 모던 리액트 Deep Dive 정리 (3장 \~ 5장)

## 3장. 리액트 훅 깊게 살펴보기

### 훅(Hook)의 의의

* 함수 컴포넌트에서 **상태 관리(state), 생명주기(lifecycle)** 같은 기능을 제공.
* 클래스 컴포넌트보다 **간결한 코드 작성** 가능.
* React 16.8(2019년) 이후 도입 → 현재 대부분의 컴포넌트는 함수 컴포넌트로 작성됨.

---

### 3.1 리액트의 모든 훅

#### 1. useState

* **역할**: 지역 상태 정의 및 관리.
* **특징**:

  * 상태 변경 시 자동으로 리렌더링 발생.
  * 초기값을 함수로 전달하면 **lazy initialization** 지원.
* **주의사항**: 상태 변경은 비동기로 처리되므로 즉시 반영되지 않을 수 있음.

#### 2. useEffect

* **역할**: 사이드 이펙트 처리 (데이터 fetch, DOM 접근, 이벤트 등록 등).
* **특징**:

  * 의존성 배열로 실행 시점 제어 가능.
  * 반환값으로 cleanup 함수 지정 → 언마운트 시 실행.
* **실수 사례**: 의존성 배열 누락 → 무한 루프 발생 가능.

#### 3. useMemo

* **역할**: 비용이 큰 계산 결과를 메모이제이션.
* **활용**:

  * 동일 입력에 대해 불필요한 연산 방지.
  * 성능 최적화에 사용.
* **주의**: 과도한 useMemo는 오히려 성능에 악영향.

#### 4. useCallback

* **역할**: 함수 객체를 메모이제이션.
* **필요성**: 자식 컴포넌트에 props로 콜백 전달 시, 참조 변경으로 인한 불필요한 리렌더링 방지.

#### 5. useRef

* **역할**: DOM 요소 참조 또는 값 유지.
* **특징**:

  * 값 변경 시 리렌더링 유발하지 않음.
  * 주로 포커스 제어, 애니메이션, 외부 라이브러리 제어에 활용.

#### 6. useContext

* **역할**: Context API와 함께 전역 상태 공유.
* **장점**: props drilling 해소.
* **단점**: Context 값이 변경되면 **모든 하위 컴포넌트가 리렌더링**됨 → 성능 저하 가능.

#### 7. useReducer

* **역할**: 복잡한 상태 로직을 reducer 패턴으로 관리.
* **장점**: 상태 관리 로직을 한 곳에 모아 구조화 가능.
* **활용**: Redux와 유사한 패턴을 컴포넌트 단위에서 사용.

#### 8. useImperativeHandle

* **역할**: 부모 컴포넌트가 자식의 메서드/값을 ref로 직접 호출 가능하게 함.
* **활용**: 모달 open/close 제어 등 특정 UI 동작 노출.

#### 9. useLayoutEffect

* **역할**: DOM 업데이트 직후 동기 실행.
* **활용**: 레이아웃 측정, 스크롤 위치 계산.
* **주의**: 렌더링 차단 가능 → 꼭 필요할 때만 사용.

#### 10. useDebugValue

* **역할**: 커스텀 훅 내부 상태를 React DevTools에서 디버깅 용도로 표시.

---

### 3.2 사용자 정의 훅 vs 고차 컴포넌트(HOC)

* **사용자 정의 훅 (Custom Hook)**

  * 상태 로직을 재사용 가능.
  * 가독성과 유지보수성이 뛰어남.
* **고차 컴포넌트 (HOC)**

  * UI 패턴 주입, props 변환에 강점.
  * Wrapper Hell 문제로 복잡해질 수 있음.
* **최근 권장사항**: 사용자 정의 훅을 우선 활용.

---

## 4장. 서버 사이드 렌더링 (SSR)

### 4.1 SPA vs SSR

* **SPA** (Single Page Application)

  * 초기 로딩 시 JS 번들을 모두 내려받음 → 초기 속도 느림.
  * SEO 취약 (검색엔진은 JS 실행 결과를 제대로 읽기 어려움).
* **SSR** (Server Side Rendering)

  * 서버에서 HTML을 렌더링 후 브라우저에 전달.
  * **장점**: 초기 로딩 속도 개선, SEO 친화적, 보안 강화.

---

### 4.2 리액트 SSR API

* **renderToString**

  * React 컴포넌트를 HTML 문자열로 변환.
  * 단점: 큰 페이지에서는 성능 부담.
* **renderToStaticMarkup**

  * React 전용 속성 제거 → 순수 HTML 출력.
* **renderToNodeStream / renderToStaticNodeStream**

  * 스트리밍 방식 렌더링 → 대규모 페이지에 유리.
* **hydrate**

  * 서버에서 생성된 HTML을 클라이언트에서 React와 연결 (인터랙션 가능).

---

### 4.3 Next.js 톺아보기

* **Next.js란?**

  * React 기반의 풀스택 프레임워크.
  * SSR + SSG(정적 사이트 생성) 모두 지원.
* **주요 기능**

  * 파일 기반 라우팅.
  * 데이터 패칭(`getStaticProps`, `getServerSideProps`).
  * 스타일링(Styled-Components, CSS Modules 등).
  * `_app.tsx`, `next.config.js`로 글로벌 설정.
* **장점**

  * SEO 최적화.
  * 리액트 18 기능과 궁합이 뛰어남.
  * DX(개발자 경험) 강화.

---

## 5장. 리액트와 상태 관리 라이브러리

### 5.1 상태 관리의 필요성

* **상태(State)**: UI, 사용자 입력, 서버 데이터 등 애플리케이션 동작에 영향을 주는 값.
* **문제점**

  * props drilling 발생.
  * 컴포넌트 간 상태 공유 어려움.
  * 규모가 커질수록 복잡도 증가.

---

### 5.2 리액트 훅을 이용한 상태 관리

1. **useState / useReducer**

   * 간단한 상태 로직 관리.
   * useReducer는 복잡한 상태 전이에 유리.
2. **useContext**

   * props drilling 해소.
   * 하지만 값 변경 시 하위 컴포넌트 전체 리렌더링 문제.

---

### 5.3 주요 상태 관리 라이브러리

#### 1. Redux

* 중앙 집중식 Store.
* 미들웨어(Redux-Saga, Thunk)로 비동기 로직 처리.
* 단점: 보일러플레이트 코드 많음.

#### 2. Recoil

* 페이스북 개발.
* 원자(atom) 단위로 상태 관리.
* Selector로 파생 상태 생성 가능.

#### 3. Jotai

* 최소한의 API 제공.
* 원자 기반 상태 관리.
* 작은 프로젝트에 적합.

#### 4. Zustand

* 훅 기반 API.
* 전역 상태를 관리하면서 불필요한 리렌더링 최소화.

#### 5. XState / Valtio / Constate / React Tracked

* XState: 유한 상태 머신 기반.
* Valtio: Proxy 기반 반응형 상태.
* Constate: Context 최적화.
* React Tracked: 리렌더링 최소화.

---

### 5.4 상태 관리 라이브러리 선택 기준

* **규모**: 앱 크기 및 복잡도.
* **철학**: 팀의 개발 스타일.
* **커뮤니티**: 유지보수/업데이트 주기, 활발한 생태계 여부.
* **리액트 호환성**: React 18 이후 기능과의 호환성.

---

# ✅ 최종 요약

* **3장 (Hooks)**: 함수 컴포넌트의 필수 기능. 로직 재사용 시 사용자 정의 훅 권장.
* **4장 (SSR)**: SPA 한계를 보완. 초기 렌더링 성능/SEO 개선. Next.js가 대표적 솔루션.
* **5장 (상태 관리)**: 규모 확장 시 필수. Redux, Recoil, Jotai, Zustand 등 상황·철학·커뮤니티에 맞춰 선택해야 함.

---